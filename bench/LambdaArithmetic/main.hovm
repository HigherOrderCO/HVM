// The Scott-Encoded Bits type
(End)  = λe λo λi e
(B0 p) = λe λo λi (o p)
(B1 p) = λe λo λi (i p)

// Applies the `f` function `xs` times to `x`
(Times xs f x) =
  let e = λf λx x
  let o = λp λf λx (Times p λk(f (f k)) x)
  let i = λp λf λx (Times p λk(f (f k)) (f x))
  (xs e o i f x)

// Increments a Bits by 1
(Inc xs) = λe λo λi (xs e i λp(o (Inc p)))

// Adds two Bits
(Add xs ys) = (Times xs λx(Inc x) ys)

// Multiplies two Bits
(Mul xs ys) = 
  let e = End
  let o = λp (B0 (Mul p ys))
  let i = λp (Add ys (B0 (Mul p ys)))
  (xs e o i)

// Converts a Bits to an U32
(ToU32 ys) =
  let e = 0
  let o = λp (+ 0 (* 2 (ToU32 p)))
  let i = λp (+ 1 (* 2 (ToU32 p)))
  (ys e o i)

// Converts an U32 to a Bits
(FromU32 0 i) = End
(FromU32 s i) = (FromU32Put (- s 1) (% i 2) (/ i 2))
  (FromU32Put s 0 i) = (B0 (FromU32 s i))
  (FromU32Put s 1 i) = (B1 (FromU32 s i))

(Main n) =
  let a = (FromU32 32 100000)
  let b = (FromU32 32 (* 100000 n))
  (ToU32 (Mul a b))

// Note: this is a faster, but uglier, version of Mul:
//(Mul xs ys) = (MulGo λx(Add ys x) xs)
  //(MulGo f xs) =
    //let e = End
    //let o = λp (B0 (MulGo f p))
    //let i = λp (f (B0 (MulGo f p)))
    //(xs e o i)
